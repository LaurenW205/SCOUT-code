# Generated by Google Gemini AI from prompt "opencv motion detection"
import cv2
import numpy as np
import time

class Node:
    def __init__(self, x, y, t):
        self.x = x
        self.y = y
        self.t = t

def xyVelocity(nodes):

    vx = []
    vy = []
    
    prev = None
    for node in nodes:
        if prev == None:
            prev = node
            continue
        
        dx = node.x - prev.x
        dy = node.y - prev.y
        dt = node.t - prev.t

        prev = node
        vx.append(dx/dt)
        vy.append(dy/dt)

    vx = np.array(vx)
    vy = np.array(vy)

    return vx, vy


    

cap = cv2.VideoCapture(0) # Use 0 for webcam, or provide video file path

# Create background subtractor
fgbg = cv2.createBackgroundSubtractorMOG2()

frame_W = int(cap.get(3))
frame_H = int(cap.get(4))
out_mp4 = cv2.VideoWriter('objTrackTest/newDebugCap.mp4', cv2.VideoWriter_fourcc(*'mp4v'), 30, (frame_W,frame_H))
recording = False
traceImg = np.zeros((frame_H, frame_W, 3), dtype=np.uint8)

nodeArray = []

while True:
    ret, frame = cap.read()
    if not ret:
        break

    blank = np.zeros((frame_H, frame_W, 3), dtype=np.uint8)
    
    # Blur to decrease noise
    blur = cv2.medianBlur(frame, 5)

    # Apply background subtractor
    fgmask = fgbg.apply(blur)

    # Thresholding
    _, thresh = cv2.threshold(fgmask, 25, 255, cv2.THRESH_BINARY)

    # Dilation (to fill gaps)
    dilated = cv2.dilate(thresh, None, iterations=2)

    # Find contours
    contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for contour in contours:
        if cv2.contourArea(contour) < 500: # Filter small contours (square pixel area)
            continue
        (x, y, w, h) = cv2.boundingRect(contour)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
        if recording == True:
            # for traced path image
            center_x = x + w//2
            center_y = y + h//2
            cv2.circle(traceImg, (center_x, center_y), 1, (0, 0, 255), -1)
            # velocity calculation data
            nodeArray.append(Node(center_x, center_y, time.time()))
            # for video file
            cv2.rectangle(blank, (x, y), (x + w, y + h), (0, 255, 0), 2)
        
    if recording == True:
        out_mp4.write(blank)

    cv2.imshow('Motion Detection', frame)
    cv2.imshow('Foreground Mask', fgmask)
    cv2.imshow('Threshold Filter', thresh)
    cv2.imshow('Dilation', dilated)
    cont_frame = frame
    cv2.imshow('Countours', cv2.drawContours(cont_frame, contours, -1, (0,255,0), 3))

    waitKey = cv2.waitKey(30) & 0xFF
    if waitKey == ord('q'):
        break
    elif waitKey == ord('r'):
        recording = not recording
    
cap.release()
out_mp4.release()
cv2.destroyAllWindows()

# calculate velocity function call
vx, vy = xyVelocity(nodeArray)

for i in range(len(vx)):
    print(f"X Velocity: {vx[i]}, Y Velocity: {vy[i]}")

cv2.imshow("Traced Path", traceImg)
while cv2.waitKey(1) != ord('q'):
    pass

cv2.destroyAllWindows()